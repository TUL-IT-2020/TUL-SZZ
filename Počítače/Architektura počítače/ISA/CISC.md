# CISC
Hlavní rodinou procesorů z vývojové větve CISC je bez pochyby 32bitová [x86](https://datasheetspdf.com/pdf-file/544568/Intel/8086/1) od [Intelu](https://www.intel.com/content/www/us/en/homepage.html) z něj odvozená architektura [AMD64](https://www.amd.com/system/files/TechDocs/24592.pdf), kde [AMD](https://www.amd.com/en) přidalo 64bitovou podporu.

Traduje se že inženýři v Intelu pracovali dlouhý čas na průlomovém procesoru, který by svými moderními vlastnostmi a bezpečným přístupem na prvním místě vytřel zrak konkurenci. AMD jim však dýchalo na paty a tak v oddělení managmentu na velitelství Intelu rozhodli udělat radikální krok a za pouhých čtrnáct dní představit svůj zbrusu nový procesor. Ve vývoji z toho nebyli nadšení a věděli že stojí před nemožným deadlinem a proto se rozhodli upustit od svého dlouho piplaného projektu a ve zbývajícím čase navrhnout něco sice mnohem méně ambiciózního, ale taky nového lepšího než má konkurence. 

Nakonec z nich vypadl procesor 8086 s 8 16bitovými registry (kde 4 jdou rozdělit každý na dva 8bitové). Ten byl kompatibilní se svými předchůdci a dával velký důraz na práci s pamětí přes stack (tedy potřebu šáhnout na pamět RAM pokaždé když chce další číslo), nikoliv registry jako takovými. Zpětně jim to nelze dávat za zlé, 16bitů opravdu není mnoho, když tam chcete nacpat adresy operandů a k ním ještě operaci jako takovou. Cena přidání registrů byla vysoká a připojovaná datová média byla zoufale pomalá, takže při nízké frekvenci na které tehdejší procesory pracovali to vyšlo prašť jak uhoď. Intel s vývojem svých procesorů přidával složitější instrukce, které stále pracovali s daty uloženými přímo v paměti. Když se procesory zrychlili pomocí pipelineningu a lepší výrobní proces s menšími tranzistory, začala se prohlubovat propast mezi vybavovacími časy paměti RAM a taktem Jádra procesoru. Nač počítat velmi rychle, když nemáte s čím? K procesorům se začala přidávat takzvaná vyrovnávací paměť cache, rychlejší než RAM, ale levnější než registry. Její hlavní výhoda tkvěla v tom že nemusíte měnit instrukční sadu. S komplexitou instrukcí také narostla spotřeba procesoru, protože je jedno že danou operaci zrovna nepoužíváte, ale ten křemík co jí tvoří musíte stejně vyrobit a život už ho napořád.

Nevýhoda architektury [x86](https://en.wikipedia.org/wiki/X86) co se týče vlastního návrhu je v tom, že vám k tomu Intel nedá své požehnání.